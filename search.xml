<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo的Next主题下文章标题的评论数显示问题</title>
    <url>/2020/12/21/Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E7%9A%84%E8%AF%84%E8%AE%BA%E6%95%B0%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>  在hexo的next主题下，使用了valine评论系统后，会自动地在文章的标题下显示出这篇文章的评论数。<br>  <a id="more"></a><br>  但文字默认的是使用”valine: “,如下图显示：</p>
<p>  <a href="https://imgchr.com/i/rcuhnA"><img src="https://s3.ax1x.com/2020/12/23/rcuhnA.png" alt="rcuhnA.png"></a></p>
<p>  不同于不蒜子计数器的修改方式，也就是在themes\next\layout_third-party\statistics下的<br>  busuanzi-counter.swig中在<span>标签前添加汉字。在themes\next\layout_macro下的有关valine的标签处修改是无效的。</p>
<p>  经过测试后需要在themes\next\languages目录下的zn-CH.yml配置文件中进行修改。</p>
<p>  具体是在下图中添加如下内容：</p>
<p>  <a href="https://imgchr.com/i/rcuWXd"><img src="https://s3.ax1x.com/2020/12/23/rcuWXd.png" alt="rcuWXd.png"></a></p>
<p>  修改完成后的效果图如下：</p>
<p>  <a href="https://imgchr.com/i/rcu40I"><img src="https://s3.ax1x.com/2020/12/23/rcu40I.png" alt="rcu40I.png"></a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java变参方法笔记</title>
    <url>/2020/12/23/Java%E5%8F%98%E5%8F%82%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一：变参方法"><a href="#一：变参方法" class="headerlink" title="一：变参方法"></a>一：变参方法</h2><p>首先，变参方法指的是可以接受任意数量参数的方法。</p>
<a id="more"></a>
<p>在定义时，他的表达形式如下：</p>
<p><code>public findMax(int... nums);</code></p>
<p>其中<code>int</code>后的“<code>...</code>”是代码的一部分，这样定义之后，该方法就可以接受任意个int型整数作为其参数。<br>可变参数只有一个，且一定在方法参数的末尾处。</p>
<p>而“<code>int...</code>”的实质是 <code>int[]</code> ，也就是<code>int</code>类型的数组，里面的每一个元素就是传入的参数，<br>从<code>int...</code>到<code>int[]</code>的过程是由编译器执行的。</p>
<h2 id="二：一些问题"><a href="#二：一些问题" class="headerlink" title="二：一些问题"></a>二：一些问题</h2><h3 id="1-当一个类中重载了两个方法如下所示："><a href="#1-当一个类中重载了两个方法如下所示：" class="headerlink" title="1. 当一个类中重载了两个方法如下所示："></a>1. 当一个类中重载了两个方法如下所示：</h3><p><code>public setParam(int x);</code><br><code>public setParam(int... x);</code></p>
<p>其中一个方法只接受一个<code>int</code>类型整数，而另一个方法接受<code>int</code>类型的可变参数.<br>这时如果调用该方法并传入一个整数a，哪个方法会被执行呢？<br>实际运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span>... items)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> item1,<span class="keyword">int</span> item2)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Demo vp = <span class="keyword">new</span> Demo();  </span><br><span class="line">        vp.comp(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上图可以看到，仅接收一个整数作为参数的方法会优先与变参方法执行。</p>
<h3 id="2-能否定义两个重载方法，其中一个接受int数组，而另一个方法接受int类型可变参数？"><a href="#2-能否定义两个重载方法，其中一个接受int数组，而另一个方法接受int类型可变参数？" class="headerlink" title="2. 能否定义两个重载方法，其中一个接受int数组，而另一个方法接受int类型可变参数？"></a>2. 能否定义两个重载方法，其中一个接受int数组，而另一个方法接受int类型可变参数？</h3><p>即，能否在一个类中定义如下两个方法：</p>
<p><code>public setParam(int[] x);</code><br><code>public setParam(int... x);</code></p>
<p>实际结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>... params)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="number">1</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] params)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="number">2</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译报错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在编写过程中，IDE就会提示错误信息，这是因为<code>int..</code>的实质就是<code>int</code>类型数组，只不过数组中存放的时传入的参数。<br>因此这两个方法本质是一样的，这就会造成编译错误。</p>
<h3 id="3-既然可变参数的本质是对应数据类型的数组，那么是否可以直接传入这样一个数组呢？"><a href="#3-既然可变参数的本质是对应数据类型的数组，那么是否可以直接传入这样一个数组呢？" class="headerlink" title="3. 既然可变参数的本质是对应数据类型的数组，那么是否可以直接传入这样一个数组呢？"></a>3. 既然可变参数的本质是对应数据类型的数组，那么是否可以直接传入这样一个数组呢？</h3><p>下图为实际结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>... params)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;params.length;i++)&#123;</span><br><span class="line">            System.out.println(params[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();  </span><br><span class="line">        demo.print(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">        demo.print(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看出，可变参数确实可以接受直接传入的数组，因为他们本质上是相同的，<br>只不过编译器会把传入的参数转换为数组形式。<br>实际上，通过这个问题，可以引申出一个小技巧，那就是对原本最后一个参数是数组的方法，完全可以<br>直接将其改造为可变参数，这样也不会破坏原有的代码。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.05.03反转位数</title>
    <url>/2021/01/07/LeetCode-05-03%E5%8F%8D%E8%BD%AC%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个32位整数<code>num</code>,你可以将一个数位从0变为1.请编写一个程序，找出你能获得的最长的一串1的长度。</p>
<a id="more"></a>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num = <span class="number">1775</span>(<span class="number">11011101111</span>)</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num = <span class="number">7</span>(<span class="number">0111</span>)</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>使用<code>String</code>对象自带的split方法，可以传入一个字符串，然后返回按照传入字符串切割出的字符串数组。<br>在本题中给split函数传入0即可。这时得到了被0分割开的字符串数组，其中每个字符串都是全为1的串。<br><font color=#FF0000>需要注意的是，连续的 <code>00</code> 中间会返回一个空串。</font><br>之后从下标为1开始遍历整个字符串数组，因为我们可以将一个0改为1，所以最终得到的全1字符串长度为当前下标对应字符串<br>加上上一个全1字符串再加1，遍历完整个数组得到的最大值就是最终结果，详细代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverseBits(int num) &#123;</span><br><span class="line">        String n &#x3D; Integer.toBinaryString(num);</span><br><span class="line">        String[] array &#x3D; n.split(&quot;0&quot;);</span><br><span class="line">        if(array.length &lt; 1) return 1;</span><br><span class="line">        int max &#x3D; array[0].length();</span><br><span class="line">        int res &#x3D; max + 1;</span><br><span class="line">        for( int i&#x3D;1;i&lt;array.length;i++)&#123;</span><br><span class="line">            if(array[i-1].length() + array[i].length() &gt; max)&#123;</span><br><span class="line">                max &#x3D; array[i-1].length() + array[i].length();</span><br><span class="line">                res &#x3D; max + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num &#x3D;&#x3D; -1) res--;</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>刚开始提交时，我发现在输入<code>num=-1</code>时，无法通过，且程序给出的答案比正确答案多1，<br>其原因是，在java中负数的二进制串是补码形式，也就是除符号位外全部取反再加1，而-1的二进制串则是<br><code>11111111111111111111111111111111</code><br>当以0分割时，只能得到一个长为32的全1字符串，而在程序中还会再加1，<br>因为程序认为根据题目要求还有一个0会变为1，而实际上在32位整数上已经没有0了，因此最大只能获得长为32的全1字符串。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位计算</tag>
      </tags>
  </entry>
</search>
